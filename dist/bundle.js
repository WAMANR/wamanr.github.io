/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./App.ts":
/*!****************!*\
  !*** ./App.ts ***!
  \****************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Game_1 = __webpack_require__(/*! ./Classes/Game */ \"./Classes/Game.ts\");\n//FONTS\nlet fontAdil = new Image();\nfontAdil.src = \"./Ressources/Fonts/adil.png\";\nlet fontRabah = new Image();\nfontRabah.src = \"./Ressources/Fonts/rabah.png\";\nlet fontStart = new Image();\nfontStart.src = \"./Ressources/Fonts/start.png\";\nlet fontTitle = new Image();\nfontTitle.src = \"./Ressources/Fonts/title.png\";\nlet fontPause = new Image();\nfontPause.src = \"./Ressources/Fonts/pause.png\";\nlet fontGenerate = new Image();\nfontGenerate.src = \"./Ressources/Fonts/generate.png\";\nfunction game_loop() {\n    actionCounter += 1;\n    game._carContext.clearRect(0, 0, game._carCanvas.width, game._carCanvas.height);\n    //game._track.draw_data(game._mapContext);\n    for (var i = 0; i < game._cars.length; i++) {\n        if (!game._isPaused) {\n            game._music.play();\n            if (actionCounter >= 2) {\n                if (keyState[\"ArrowUp\"]) {\n                    game._cars[0].accelerate();\n                }\n                if (keyState[\"ArrowDown\"]) {\n                    game._cars[0].deccelerate();\n                }\n                if (keyState[\"ArrowLeft\"]) {\n                    game._cars[0].steering(true);\n                }\n                if (keyState[\"ArrowRight\"]) {\n                    game._cars[0].steering(false);\n                }\n                if (keyState[\"z\"]) {\n                    game._cars[1].accelerate();\n                }\n                if (keyState[\"s\"]) {\n                    game._cars[1].deccelerate();\n                }\n                if (keyState[\"q\"]) {\n                    game._cars[1].steering(true);\n                }\n                if (keyState[\"d\"]) {\n                    game._cars[1].steering(false);\n                }\n                actionCounter = 0;\n            }\n            if (game._cars[i]._isIA) {\n                game._cars[i].behavior();\n            }\n            game._cars[i].speed_limit();\n            game._cars[i].update_pos();\n        }\n        game._cars[i].draw();\n    }\n    if (game._isPaused)\n        draw_UI();\n}\nfunction game_init() {\n    game._mapContext.clearRect(0, 0, game._mapCanvas.width, game._mapCanvas.height);\n    game._tunnelContext.clearRect(0, 0, game._tunnelCanvas.width, game._tunnelCanvas.height);\n    game._cars = new Array();\n    game.make_track();\n    game.init_background();\n    game.init_scenery();\n    game.new_car(game._track._start[0] * 60 + 12, game._track._start[1] * 60 + 22, 0, false);\n    game.new_car(game._track._start[0] * 60 + 12, game._track._start[1] * 60 + 36, 1, false);\n    game.new_car(game._track._start[0] * 60 + 32, game._track._start[1] * 60 + 22, 2, true);\n    game.new_car(game._track._start[0] * 60 + 32, game._track._start[1] * 60 + 36, 3, true);\n    //game.draw_background();\n    //game._track.draw(1);\n    //game.draw_scenery();\n    game.draw_tunnels();\n}\nfunction draw_UI() {\n    game._mapContext.beginPath();\n    game._mapContext.globalAlpha = 0.6;\n    game._mapContext.fillStyle = \"#000011\";\n    game._mapContext.fillRect(0, 0, 1024, 768);\n    game._mapContext.closePath();\n    game._mapContext.beginPath();\n    game._mapContext.fillRect(50, 400, 400, 200);\n    game._mapContext.fillRect(560, 400, 400, 200);\n    game._mapContext.closePath();\n    game._mapContext.globalAlpha = 1;\n    game._mapContext.drawImage(fontTitle, 220, 50, 800, 500);\n    game._mapContext.drawImage(fontGenerate, 50, 400, 510, 350);\n    game._mapContext.drawImage(fontStart, 590, 410, 700, 500);\n}\nfunction clickButton(event) {\n    var x = event.clientX;\n    var y = event.clientY;\n    if (x >= 50 && x <= 450 && y >= 400 && y <= 600) {\n        game_init();\n    }\n    else if (x >= 560 && x <= 960 && y >= 400 && y <= 600) {\n        game.draw_background();\n        game._track.draw(1);\n        game.draw_scenery();\n        game.draw_tunnels();\n        game._isPaused = false;\n    }\n}\nlet actionCounter = 0;\nconst keyState = {};\nfunction handleKeyPress(event) {\n    keyState[event.key] = true;\n    event.preventDefault();\n}\nfunction handleKeyRelease(event) {\n    keyState[event.key] = false;\n}\n///////////////////////////////////////////Game execution/////////////////////////////////////////////////////\nlet game = new Game_1.Game(17, 13, 60);\ngame_init();\ndocument.addEventListener(\"click\", clickButton);\ndocument.addEventListener(\"keydown\", handleKeyPress);\ndocument.addEventListener(\"keyup\", handleKeyRelease);\nsetInterval(game_loop, 20);\n\n\n//# sourceURL=webpack://jeu/./App.ts?");

/***/ }),

/***/ "./Classes/Car.ts":
/*!************************!*\
  !*** ./Classes/Car.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Car = void 0;\nconst RessourcesPaths_1 = __webpack_require__(/*! ./RessourcesPaths */ \"./Classes/RessourcesPaths.ts\");\n//Classe qui représente et gère le comportements des voitures.\nclass Car {\n    constructor(x, y, angle, type, track, carContext, isIa) {\n        this._x = x;\n        this._y = y;\n        this._angle = angle;\n        this._steeringAngle = 0;\n        this._speed = 0;\n        this._startSpeed = 0;\n        this._maxSpeed = 0;\n        this._minSpeed = 0;\n        this._acceleration = 0;\n        this._brakeSpeed = 0;\n        this._collision = false;\n        this._firstCollision = false;\n        this._track = track;\n        this._carContext = carContext;\n        this._isIA = isIa;\n        this._imageCar = new Image();\n        switch (type) {\n            case 0:\n                this._imageCar.src = RessourcesPaths_1.RessourcesPaths.REDCAR; //red car\n                this._acceleration = 1.08;\n                this._maxSpeed = 2;\n                this._minSpeed = -0.5;\n                this._brakeSpeed = 1.02;\n                this._startSpeed = 0.5;\n                this._steeringAngle = Math.PI / 29;\n                break;\n            case 1:\n                this._imageCar.src = RessourcesPaths_1.RessourcesPaths.GREENCAR; //green car\n                this._acceleration = 1.08;\n                this._maxSpeed = 3;\n                this._brakeSpeed = 1.09;\n                this._startSpeed = 0.45;\n                this._steeringAngle = Math.PI / 31;\n                break;\n            case 2:\n                this._imageCar.src = RessourcesPaths_1.RessourcesPaths.YELLOWCAR; //yellow car\n                this._acceleration = 1.01;\n                this._maxSpeed = 2;\n                this._brakeSpeed = 1.085;\n                this._startSpeed = 0.4;\n                this._steeringAngle = Math.PI / 31.5;\n                break;\n            case 3:\n                this._imageCar.src = RessourcesPaths_1.RessourcesPaths.BLACKCAR; //black car\n                this._acceleration = 1.02;\n                this._maxSpeed = 1.9;\n                this._brakeSpeed = 1.09;\n                this._startSpeed = 0.3;\n                this._steeringAngle = Math.PI / 31;\n                break;\n        }\n    }\n    behavior() {\n        var left = this.visibility(-(Math.PI / 4), this._x, this._y);\n        var right = this.visibility(Math.PI / 4, this._x, this._y);\n        var front = this.visibility(0, this._x, this._y);\n        if ((right - left) * this._steeringAngle > 2)\n            this.steering(true);\n        else if ((left - right) * this._steeringAngle > 2)\n            this.steering(false);\n        if ((this._speed * 15) * this._acceleration < front / 2)\n            this.accelerate();\n        else if ((this._speed * 8) * this._brakeSpeed > front)\n            this.deccelerate();\n    }\n    visibility(angle, x, y) {\n        var fx = x;\n        var fy = y;\n        var acc = 0;\n        while (this.onTheRoad(fx, fy)) {\n            acc++;\n            fx = fx + Math.cos(-this._angle - angle);\n            fy = fy + Math.sin(-this._angle - angle);\n        }\n        return acc;\n    }\n    apply_friction() {\n        this._speed *= 0.95;\n    }\n    accelerate() {\n        if (!this._collision) {\n            if (this._speed > 0) {\n                this._speed *= this._acceleration; // Accelerate\n            }\n            else if (this._speed < 0.5) {\n                this._speed = this._startSpeed;\n            }\n            else {\n                this._speed = this._startSpeed;\n            }\n        }\n    }\n    deccelerate() {\n        if (this._speed < 0) {\n            this._speed *= this._acceleration;\n        }\n        else if (this._speed > 0) {\n            this._speed *= 1 - (this._brakeSpeed - 1) * 5;\n        }\n        else {\n            this._speed = -1 * this._startSpeed;\n        }\n    }\n    speed_limit() {\n        if (this._speed > 0) {\n            if (this._speed > this._maxSpeed)\n                this._speed = this._maxSpeed;\n        }\n        else if (this._speed < 0) {\n            if (this._speed < -1 / 2 * this._maxSpeed)\n                this._speed = -1 / 2 * this._maxSpeed;\n        }\n    }\n    steering(left) {\n        if (this._speed > 0) {\n            if (left)\n                this._angle += this._steeringAngle;\n            else if (!left)\n                this._angle -= this._steeringAngle;\n        }\n        if (this._angle > 2 * Math.PI)\n            this._angle %= 2 * Math.PI;\n    }\n    detect_collision() {\n        let front = [this._x + Math.cos(-this._angle) * 6, this._y + Math.sin(-this._angle) * 3];\n        var back = [this._x - Math.cos(-this._angle) * 6, this._y - Math.sin(-this._angle) * 3];\n        var right = [this._x - Math.cos(-this._angle - Math.PI / 2) * 6, this._y - Math.sin(-this._angle - Math.PI / 2) * 3];\n        var left = [this._x - Math.cos(-this._angle + Math.PI / 2) * 6, this._y - Math.sin(-this._angle + Math.PI / 2) * 3];\n        var cfr = [(front[0] - this._x) + right[0], (front[1] - this._y) + right[1]];\n        var cfl = [(front[0] - this._x) + left[0], (front[1] - this._y) + left[1]];\n        var cbr = [(back[0] - this._x) + right[0], (back[1] - this._y) + right[1]];\n        var cbl = [(back[0] - this._x) + left[0], (back[1] - this._y) + left[1]];\n        if (!this.onTheRoad(cfr[0], cfr[1])) {\n            this._collision = true;\n            return;\n        }\n        if (!this.onTheRoad(cfl[0], cfl[1])) {\n            this._collision = true;\n            return;\n        }\n        if (!this.onTheRoad(cbr[0], cbr[1])) {\n            this._collision = true;\n            return;\n        }\n        if (!this.onTheRoad(cbl[0], cbl[1])) {\n            this._collision = true;\n            return;\n        }\n        this._collision = false;\n    }\n    onTheRoad(x, y) {\n        if (x < 0 || y < 0 || x > 1024 || y > 768)\n            return false;\n        var i = Math.round(y) * 1024 + Math.round(x);\n        return this._track._dataArray[i];\n    }\n    update_pos() {\n        //this.apply_friction();\n        var xTmp = this._x;\n        var yTmp = this._y;\n        this._x += this._speed * Math.cos(this._angle);\n        this._y -= this._speed * Math.sin(this._angle);\n        this.detect_collision();\n        if (this._collision) {\n            if (!this._firstCollision) {\n                this._firstCollision = true;\n                this._x = xTmp;\n                this._y = yTmp;\n            }\n            this._speed = -2 * this._speed / 2;\n        }\n        else {\n            if (this._firstCollision) {\n                this._firstCollision = false;\n            }\n        }\n    }\n    draw() {\n        this._carContext.save();\n        this._carContext.translate(this._x, this._y);\n        this._carContext.rotate(-this._angle);\n        this._carContext.translate(-8, -4);\n        this._carContext.drawImage(this._imageCar, 0, 0, 16, 8);\n        this._carContext.restore();\n    }\n}\nexports.Car = Car;\n\n\n//# sourceURL=webpack://jeu/./Classes/Car.ts?");

/***/ }),

/***/ "./Classes/Game.ts":
/*!*************************!*\
  !*** ./Classes/Game.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Game = void 0;\nconst Track_1 = __webpack_require__(/*! ./Track */ \"./Classes/Track.ts\");\nconst Car_1 = __webpack_require__(/*! ./Car */ \"./Classes/Car.ts\");\nconst RessourcesPaths_1 = __webpack_require__(/*! ./RessourcesPaths */ \"./Classes/RessourcesPaths.ts\");\nclass Game {\n    constructor(tileX, tileY, _tileSize) {\n        // Game context handler\n        this._mapCanvas = document.getElementById('mapCanvas');\n        this._mapContext = this._mapCanvas.getContext('2d');\n        this._mapContext.imageSmoothingEnabled = false;\n        this._carCanvas = document.getElementById('carCanvas');\n        this._carContext = this._carCanvas.getContext('2d');\n        this._carContext.imageSmoothingEnabled = false;\n        this._tunnelCanvas = document.getElementById('tunnelCanvas');\n        this._tunnelContext = this._tunnelCanvas.getContext('2d');\n        this._tunnelContext.imageSmoothingEnabled = false;\n        this._mapCanvas.height = 1000;\n        this._mapCanvas.width = 1280;\n        this._carCanvas.height = 1000;\n        this._carCanvas.width = 1280;\n        this._tunnelCanvas.height = 1000;\n        this._tunnelCanvas.width = 1280;\n        // Game running handler\n        this._isPaused = true;\n        this._isInGame = false;\n        // Cars\n        this._cars = [];\n        // Tiles\n        this._tileSize = _tileSize;\n        this._width = tileX;\n        this._height = tileY;\n        // Background\n        this._bgWidth = tileX * 4;\n        this._bgHeight = tileY * 4;\n        this._bgTileSize = Math.round(_tileSize / 4);\n        this._bgArray = new Array(this._bgWidth * this._bgHeight);\n        // Scenery\n        this._scWidth = tileX * 2;\n        this._scHeight = tileY * 2;\n        this._scTileSize = Math.round(_tileSize / 2);\n        this._scArray = new Array(this._scWidth * this._scHeight);\n        //Music\n        this._music = new Audio(RessourcesPaths_1.RessourcesPaths.THEME);\n        //Assets\n        this._imageGrass = new Image();\n        this._imageGrass.src = RessourcesPaths_1.RessourcesPaths.IMAGEGRASS;\n        this._imageDry = new Image();\n        this._imageDry.src = RessourcesPaths_1.RessourcesPaths.IMAGEDRY;\n        this._imageSand = new Image();\n        this._imageSand.src = RessourcesPaths_1.RessourcesPaths.IMAGESAND;\n        this._imageGround = new Image();\n        this._imageGround.src = RessourcesPaths_1.RessourcesPaths.IMAGEGROUND;\n        this._imageBush1 = new Image();\n        this._imageBush1.src = RessourcesPaths_1.RessourcesPaths.IMAGEBUSH1;\n        this._imageBush2 = new Image();\n        this._imageBush2.src = RessourcesPaths_1.RessourcesPaths.IMAGEBUSH2;\n        this._imageTree1 = new Image();\n        this._imageTree1.src = RessourcesPaths_1.RessourcesPaths.IMAGETREE1;\n        this._imageTree2 = new Image();\n        this._imageTree2.src = RessourcesPaths_1.RessourcesPaths.IMAGETREE2;\n        this._imageStart = new Image();\n        this._imageStart.src = RessourcesPaths_1.RessourcesPaths.IMAGESTART;\n        this._imageRoofConcrete = new Image();\n        this._imageRoofConcrete.src = RessourcesPaths_1.RessourcesPaths.IMAGEROOFCONCRETE;\n        this._imageRoofDust = new Image();\n        this._imageRoofDust.src = RessourcesPaths_1.RessourcesPaths.IMAGEROOFDUST;\n        // Track\n        this._track = new Track_1.Track(this._width, this._height, 3, this._tileSize, this._mapContext);\n        this._track.init_mapArray();\n    }\n    make_track() {\n        this._track = new Track_1.Track(this._width, this._height, 3, this._tileSize, this._mapContext);\n        this._track.init_mapArray();\n    }\n    new_car(x, y, type, isIa) {\n        let newCar = new Car_1.Car(x, y, 0, type, this._track, this._carContext, isIa);\n        this._cars.push(newCar);\n    }\n    ////////////////BACKGROUND\n    init_background() {\n        this.bg_zero_mapArray();\n        this.make_background();\n    }\n    bg_zero_mapArray() {\n        for (var i = 0; i < this._bgArray.length; i++) {\n            this._bgArray[i] = 0;\n        }\n    }\n    make_background() {\n        let tileLeft = this._bgWidth * this._bgHeight;\n        let x = 1;\n        let y = 1;\n        let acc = 1;\n        let randNumb = 1;\n        let ranDir = 1;\n        let randStart = 1;\n        let tileType = 1;\n        while (tileLeft) {\n            acc = 0;\n            for (var i = 0; i < this._bgArray.length; i++) {\n                if (!this._bgArray[i])\n                    acc++;\n            }\n            randStart = Math.floor(Math.random() * acc + 1);\n            for (i = 0; i < this._bgArray.length; i++) {\n                if (!randStart) {\n                    x = i % this._bgWidth;\n                    y = Math.floor(i / this._bgWidth);\n                    break;\n                }\n                else if (!this._bgArray[i])\n                    randStart--;\n            }\n            if (tileType == 1)\n                tileType = 2;\n            else if (tileType == 2)\n                tileType = 3;\n            else if (tileType == 3)\n                tileType = 4;\n            else if (tileType == 4)\n                tileType = 1;\n            randNumb = Math.floor(Math.random() * (tileLeft / 2) + 1);\n            while (randNumb) {\n                var direction = [];\n                if (y - 1 >= 0 && !this.bg_get_array_value(x, y - 1)) {\n                    direction.push(0);\n                }\n                if (x - 1 >= 0 && !this.bg_get_array_value(x - 1, y)) {\n                    direction.push(1);\n                }\n                if (y + 1 <= this._bgHeight - 1 && !this.bg_get_array_value(x, y + 1)) {\n                    direction.push(2);\n                }\n                if (x + 1 <= this._bgWidth - 1 && !this.bg_get_array_value(x + 1, y)) {\n                    direction.push(3);\n                }\n                if (!direction.length)\n                    break;\n                ranDir = Math.floor(Math.random() * direction.length);\n                if (!direction[ranDir]) {\n                    this.bg_put_array_value(x, y, tileType);\n                    randNumb--;\n                    tileLeft--;\n                    y = y - 1;\n                }\n                else if (direction[ranDir] == 1) {\n                    this.bg_put_array_value(x, y, tileType);\n                    randNumb--;\n                    tileLeft--;\n                    x = x - 1;\n                }\n                else if (direction[ranDir] == 2) {\n                    this.bg_put_array_value(x, y, tileType);\n                    randNumb--;\n                    tileLeft--;\n                    y = y + 1;\n                }\n                else {\n                    this.bg_put_array_value(x, y, tileType);\n                    randNumb--;\n                    tileLeft--;\n                    x = x + 1;\n                }\n            }\n        }\n    }\n    bg_get_array_value(x, y) {\n        return this._bgArray[x + (y * this._bgWidth)];\n    }\n    bg_put_array_value(x, y, value) {\n        this._bgArray[x + (y * this._bgWidth)] = value;\n    }\n    draw_background() {\n        for (var i = 0; i < this._bgArray.length; i++) {\n            if (this._bgArray[i] == 1) {\n                this._mapContext.drawImage(this._imageGrass, (i % this._bgWidth) * this._bgTileSize, Math.floor(i / this._bgWidth) * this._bgTileSize, this._bgTileSize, this._bgTileSize);\n            }\n            else if (this._bgArray[i] == 2) {\n                this._mapContext.drawImage(this._imageDry, (i % this._bgWidth) * this._bgTileSize, Math.floor(i / this._bgWidth) * this._bgTileSize, this._bgTileSize, this._bgTileSize);\n            }\n            else if (this._bgArray[i] == 3) {\n                this._mapContext.drawImage(this._imageSand, (i % this._bgWidth) * this._bgTileSize, Math.floor(i / this._bgWidth) * this._bgTileSize, this._bgTileSize, this._bgTileSize);\n            }\n            else\n                this._mapContext.drawImage(this._imageGround, (i % this._bgWidth) * this._bgTileSize, Math.floor(i / this._bgWidth) * this._bgTileSize, this._bgTileSize, this._bgTileSize);\n        }\n    }\n    ////////////////SCENERY\n    init_scenery() {\n        this.sc_zero_mapArray();\n        this.make_scenery();\n        this.make_tunnels();\n    }\n    sc_zero_mapArray() {\n        for (var i = 0; i < this._scArray.length; i++) {\n            this._scArray[i] = 0;\n        }\n    }\n    make_scenery() {\n        let acc = 0;\n        let tileCount = 0;\n        let tileLeftCp = 0;\n        let x = 0;\n        let y = 0;\n        let randTile = 0;\n        let tileChoice = 0;\n        var tileLeft = this._scArray.length;\n        for (var j = 0; j < this._scHeight; j++) {\n            for (var i = 0; i < this._scWidth; i++) {\n                if (this._track.get_array_value(Math.floor(i / 2), Math.floor(j / 2)) >= 0) {\n                    tileLeft--;\n                    this.sc_put_array_value(i, j, -1);\n                }\n            }\n        }\n        tileCount = Math.floor(Math.round(tileLeft / 1.5));\n        while (tileCount) {\n            randTile = Math.floor(Math.random() * tileLeft + 1);\n            for (i = 0; i < this._scArray.length; i++) {\n                if (!randTile) {\n                    x = i % this._scWidth;\n                    y = Math.floor(i / this._scWidth);\n                    break;\n                }\n                else if (this._scArray[i] == 0)\n                    randTile--;\n            }\n            tileChoice = Math.floor(Math.random() * 4 + 1);\n            this.sc_put_array_value(x, y, tileChoice);\n            tileLeft--;\n            tileCount--;\n        }\n        this.sc_put_array_value(this._track._start[0] * 2, this._track._start[1] * 2, 5);\n    }\n    make_tunnels() {\n        let i;\n        let j;\n        let x = 0;\n        let y, randT, tNumbers;\n        var straightTile = 0;\n        for (i = 0; i < this._track._mapArray.length; i++) {\n            if ((i % this._track._width != this._track._start[0] && Math.floor(i / this._track._width) != this._track._start[1])\n                && (this._track._mapArray[i] == 0 || this._track._mapArray[i] == 1))\n                straightTile++;\n        }\n        tNumbers = Math.floor(straightTile / 2);\n        while (tNumbers) {\n            randT = Math.floor(Math.random() * straightTile);\n            for (j = 0; j < this._track._height && randT; j++) {\n                for (i = 0; i < this._track._width && randT; i++) {\n                    if ((i != this._track._start[0] && j != this._track._start[1]) &&\n                        (this._track.get_array_value(i, j) == 0 || this._track.get_array_value(i, j) == 1))\n                        randT--;\n                }\n            }\n            this.sc_put_array_value(i * 2 - 2, j * 2 - 2, 6);\n            tNumbers--;\n            straightTile--;\n        }\n    }\n    sc_put_array_value(x, y, value) {\n        this._scArray[x + (y * this._scWidth)] = value;\n    }\n    sc_get_array_value(x, y) {\n        return this._scArray[x + (y * this._scWidth)];\n    }\n    draw_scenery() {\n        for (var i = 0; i < this._scArray.length; i++) {\n            if (this._scArray[i] == 1) {\n                this._mapContext.drawImage(this._imageBush1, ((i - 1) % this._scWidth) * this._scTileSize, Math.floor(i / this._scWidth) * this._scTileSize, this._scTileSize, this._scTileSize);\n            }\n            else if (this._scArray[i] == 2) {\n                this._mapContext.drawImage(this._imageBush2, ((i - 1) % this._scWidth) * this._scTileSize, Math.floor(i / this._scWidth) * this._scTileSize, this._scTileSize, this._scTileSize);\n            }\n            if (this._scArray[i] == 3) {\n                this._mapContext.drawImage(this._imageTree1, ((i - 1) % this._scWidth) * this._scTileSize, Math.floor(i / this._scWidth) * this._scTileSize, this._scTileSize, this._scTileSize);\n            }\n            else if (this._scArray[i] == 4) {\n                this._mapContext.drawImage(this._imageTree2, ((i - 1) % this._scWidth) * this._scTileSize, Math.floor(i / this._scWidth) * this._scTileSize, this._scTileSize, this._scTileSize);\n            }\n            else if (this._scArray[i] == 5) {\n                this._mapContext.drawImage(this._imageStart, ((i + 1) % this._scWidth) * this._scTileSize + this._scTileSize / 2, Math.floor(i / this._scWidth) * this._scTileSize + this._scTileSize / 4, this._scTileSize - this._scTileSize / 2, this._scTileSize * 1.5);\n            }\n        }\n    }\n    draw_tunnels() {\n        for (var i = 0; i < this._scArray.length; i++) {\n            if (this._scArray[i] == 6) {\n                this._tunnelContext.globalAlpha = 0.6;\n                if (this._track._roadType == 1)\n                    this._tunnelContext.drawImage(this._imageRoofConcrete, (i % this._scWidth) * this._scTileSize, Math.floor(i / this._scWidth) * this._scTileSize, this._scTileSize * 2, this._scTileSize * 2);\n                else\n                    this._tunnelContext.drawImage(this._imageRoofDust, (i % this._scWidth) * this._scTileSize, Math.floor(i / this._scWidth) * this._scTileSize, this._scTileSize * 2, this._scTileSize * 2);\n                this._tunnelContext.globalAlpha = 1;\n            }\n        }\n    }\n}\nexports.Game = Game;\n\n\n//# sourceURL=webpack://jeu/./Classes/Game.ts?");

/***/ }),

/***/ "./Classes/RessourcesPaths.ts":
/*!************************************!*\
  !*** ./Classes/RessourcesPaths.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RessourcesPaths = void 0;\nclass RessourcesPaths {\n}\nexports.RessourcesPaths = RessourcesPaths;\n//Cars\nRessourcesPaths.REDCAR = \"../Ressources/Cars/car.png\";\nRessourcesPaths.GREENCAR = \"../Ressources/Cars/car1.png\";\nRessourcesPaths.YELLOWCAR = \"../Ressources/Cars/car2.png\";\nRessourcesPaths.BLACKCAR = \"../Ressources/Cars/car3.png\";\n//Roads\nRessourcesPaths.IMAGEROADHIDDEN = \"../Ressources/Roads/road_hidden.png\";\nRessourcesPaths.IMAGEROADCONCRETE = \"../Ressources/Roads/road_concrete.png\";\nRessourcesPaths.IMAGEROADDUST = \"../Ressources/Roads/road_dust.png\";\n//Scenery\nRessourcesPaths.IMAGEGRASS = \"../Ressources/Scenery/grass.png\";\nRessourcesPaths.IMAGEDRY = \"../Ressources/Scenery/drygrass.png\";\nRessourcesPaths.IMAGESAND = \"../Ressources/Scenery/bigsand.png\";\nRessourcesPaths.IMAGEGROUND = \"../Ressources/Scenery/ground.png\";\nRessourcesPaths.IMAGEBUSH1 = \"../Ressources/Scenery/Bush_01.png\";\nRessourcesPaths.IMAGEBUSH2 = \"../Ressources/Scenery/Bush_02.png\";\nRessourcesPaths.IMAGETREE1 = \"../Ressources/Scenery/Tree_01.png\";\nRessourcesPaths.IMAGETREE2 = \"../Ressources/Scenery/Tree_02.png\";\nRessourcesPaths.IMAGESTART = \"../Ressources/Scenery/Start.png\";\nRessourcesPaths.IMAGEROOFCONCRETE = \"../Ressources/Scenery/roof_concrete.png\";\nRessourcesPaths.IMAGEROOFDUST = \"../Ressources/Scenery/roof_dust.png\";\n//Sounds\nRessourcesPaths.THEME = \"../Ressources/Sound/theme.mp3\";\n\n\n//# sourceURL=webpack://jeu/./Classes/RessourcesPaths.ts?");

/***/ }),

/***/ "./Classes/Track.ts":
/*!**************************!*\
  !*** ./Classes/Track.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Track = void 0;\nconst RessourcesPaths_1 = __webpack_require__(/*! ./RessourcesPaths */ \"./Classes/RessourcesPaths.ts\");\nclass Track {\n    constructor(width, height, trackRatio, tileSize, ctx) {\n        this._height = height;\n        this._width = width;\n        this._trackRatio = trackRatio;\n        this._mapArray = new Array(height * width);\n        this._dataArray = [];\n        this._start = [];\n        this._tileSize = tileSize;\n        this._roadType = Math.floor(Math.random() * 2 + 1);\n        this._mapContext = ctx;\n        //ROADS\n        this._imageRoadHidden = new Image();\n        this._imageRoadHidden.src = RessourcesPaths_1.RessourcesPaths.IMAGEROADHIDDEN;\n        this._imageRoadConcrete = new Image();\n        this._imageRoadConcrete.src = RessourcesPaths_1.RessourcesPaths.IMAGEROADCONCRETE;\n        this._imageRoadDust = new Image();\n        this._imageRoadDust.src = RessourcesPaths_1.RessourcesPaths.IMAGEROADDUST;\n    }\n    pushInto_dataArray() {\n        this.white_canva();\n        this.draw(0);\n        var k = this._mapContext.getImageData(0, 0, 1024, 768).data;\n        var j;\n        for (var i = 0; i < k.length / 4; i++) {\n            j = 4 * i;\n            if (k[j] === 0 && k[j + 1] === 0 && k[j + 2] === 0) {\n                this._dataArray.push(true);\n            }\n            else {\n                this._dataArray.push(false);\n            }\n        }\n    }\n    init_mapArray() {\n        this.zero_mapArray();\n        this.create_road();\n        this.draw_road();\n        this.pushInto_dataArray();\n        this.choose_start();\n    }\n    choose_start() {\n        for (var i = 0; i < this._mapArray.length; i++) {\n            if (this._mapArray[i] == 1) {\n                this._start[0] = i % this._width;\n                this._start[1] = Math.floor(i / this._width);\n                return;\n            }\n        }\n    }\n    zero_mapArray() {\n        for (var i = 0; i < this._mapArray.length; i++) {\n            this._mapArray[i] = 0;\n        }\n    }\n    create_road() {\n        var x = Math.floor(Math.random() * this._width);\n        var y = Math.floor(Math.random() * this._height);\n        this.put_array_value(x, y, 1);\n        this._start = [x, y];\n        this.next_road(x, y, 1);\n        var roadNbr = 0;\n        for (var i = 0; i < this._mapArray.length; i++) {\n            if (this._mapArray[i] > 0)\n                roadNbr++;\n        }\n        if (roadNbr < (this._height * this._width) / this._trackRatio) {\n            this.zero_mapArray();\n            this.create_road();\n        }\n        else {\n        }\n    }\n    draw_road() {\n        var val1, val2, valCurrent;\n        var valMax = this.get_array_max_value();\n        var tmpArray = new Array(this._height * this._width);\n        for (var y = 0; y < this._height; y++) {\n            for (var x = 0; x < this._width; x++) {\n                valCurrent = this.get_array_value(x, y);\n                if (valCurrent < 1)\n                    tmpArray[x + (y * this._width)] = -1;\n                else {\n                    if (valCurrent == valMax) {\n                        val1 = 1;\n                        val2 = valCurrent - 1;\n                    }\n                    else if (valCurrent == 1) {\n                        val1 = 2;\n                        val2 = valMax;\n                    }\n                    else {\n                        val1 = valCurrent - 1;\n                        val2 = valCurrent + 1;\n                    }\n                    if (y - 1 >= 0 && y + 1 <= this._height - 1) { // straight vertical\n                        if ((val1 == this.get_array_value(x, y - 1) && val2 == this.get_array_value(x, y + 1)) ||\n                            (val2 == this.get_array_value(x, y - 1) && val1 == this.get_array_value(x, y + 1))) {\n                            tmpArray[x + (y * this._width)] = 0;\n                            continue;\n                        }\n                    }\n                    if (x - 1 >= 0 && x + 1 <= this._width - 1) { //straight horizontal\n                        if ((val1 == this.get_array_value(x - 1, y) && val2 == this.get_array_value(x + 1, y)) ||\n                            (val2 == this.get_array_value(x - 1, y) && val1 == this.get_array_value(x + 1, y))) {\n                            tmpArray[x + (y * this._width)] = 1;\n                            continue;\n                        }\n                    }\n                    if (y + 1 <= this._height - 1 && x + 1 <= this._width - 1) { // corner top left\n                        if ((val1 == this.get_array_value(x + 1, y) && val2 == this.get_array_value(x, y + 1)) ||\n                            (val2 == this.get_array_value(x + 1, y) && val1 == this.get_array_value(x, y + 1))) {\n                            tmpArray[x + (y * this._width)] = 2;\n                            continue;\n                        }\n                    }\n                    if (x - 1 >= 0 && y + 1 <= this._height - 1) { // corner top right\n                        if ((val1 == this.get_array_value(x - 1, y) && val2 == this.get_array_value(x, y + 1)) ||\n                            (val2 == this.get_array_value(x - 1, y) && val1 == this.get_array_value(x, y + 1))) {\n                            tmpArray[x + (y * this._width)] = 3;\n                            continue;\n                        }\n                    }\n                    if (x + 1 <= this._width - 1 && y - 1 >= 0) { // corner bottom left\n                        if ((val1 == this.get_array_value(x + 1, y) && val2 == this.get_array_value(x, y - 1)) ||\n                            (val2 == this.get_array_value(x + 1, y) && val1 == this.get_array_value(x, y - 1))) {\n                            tmpArray[x + (y * this._width)] = 4;\n                            continue;\n                        }\n                    }\n                    if (x - 1 >= 0 && y - 1 >= 0) { // corner bottom right\n                        if ((val1 == this.get_array_value(x - 1, y) && val2 == this.get_array_value(x, y - 1)) ||\n                            (val2 == this.get_array_value(x - 1, y) && val1 == this.get_array_value(x, y - 1))) {\n                            tmpArray[x + (y * this._width)] = 5;\n                            continue;\n                        }\n                    }\n                }\n            }\n        }\n        this._mapArray = tmpArray;\n    }\n    next_road(x, y, acc) {\n        if (x != this._start[0] || y != this._start[1])\n            this.put_array_value(x, y, acc);\n        for (var i = 0; i < this._mapArray.length; i++) {\n            if (this._mapArray[i] < 1)\n                this._mapArray[i] = -2;\n        }\n        this.give_score_to_case(this._start[0], this._start[1]);\n        var direction = [];\n        if (y - 1 >= 0 && this.get_array_value(x, y - 1) == -1) {\n            direction.push(0);\n        }\n        if (x - 1 >= 0 && this.get_array_value(x - 1, y) == -1) {\n            direction.push(1);\n        }\n        if (y + 1 <= this._height - 1 && this.get_array_value(x, y + 1) == -1) {\n            direction.push(2);\n        }\n        if (x + 1 <= this._width - 1 && this.get_array_value(x + 1, y) == -1) {\n            direction.push(3);\n        }\n        if (!direction.length)\n            return;\n        var ranDir = Math.floor(Math.random() * direction.length);\n        if (!direction[ranDir]) {\n            this.next_road(x, y - 1, ++acc);\n        }\n        else if (direction[ranDir] == 1) {\n            this.next_road(x - 1, y, ++acc);\n        }\n        else if (direction[ranDir] == 2) {\n            this.next_road(x, y + 1, ++acc);\n        }\n        else {\n            this.next_road(x + 1, y, ++acc);\n        }\n    }\n    get_array_max_value() {\n        var valMax = 0;\n        for (var i = 0; i < this._mapArray.length; i++) {\n            if (this._mapArray[i] > valMax)\n                valMax = this._mapArray[i];\n        }\n        return valMax;\n    }\n    get_array_value(x, y) {\n        return this._mapArray[x + (y * this._width)];\n    }\n    put_array_value(x, y, value) {\n        this._mapArray[x + (y * this._width)] = value;\n    }\n    give_score_to_case(x, y) {\n        if (y - 1 >= 0 && (this.get_array_value(x, y - 1) <= 0 && this.get_array_value(x, y - 1) != -1)) {\n            this.put_array_value(x, y - 1, -1);\n            this.give_score_to_case(x, y - 1);\n        }\n        if (x - 1 >= 0 && (this.get_array_value(x - 1, y) <= 0 && this.get_array_value(x - 1, y) != -1)) {\n            this.put_array_value(x - 1, y, -1);\n            this.give_score_to_case(x - 1, y);\n        }\n        if (y + 1 <= this._height - 1 && (this.get_array_value(x, y + 1) <= 0 && this.get_array_value(x, y + 1) != -1)) {\n            this.put_array_value(x, y + 1, -1);\n            this.give_score_to_case(x, y + 1);\n        }\n        if (x + 1 <= this._width - 1 && (this.get_array_value(x + 1, y) <= 0 && this.get_array_value(x + 1, y) != -1)) {\n            this.put_array_value(x + 1, y, -1);\n            this.give_score_to_case(x + 1, y);\n        }\n    }\n    white_canva() {\n        this._mapContext.fillStyle = \"#FFFFFF\";\n        this._mapContext.fillRect(0, 0, 1024, 768);\n    }\n    draw(type) {\n        var sx, sy;\n        var sourceRoad = {\n            \"straightVertical\": [256, 256], \"straightHorizontal\": [256, 0], \"cornerTopLeft\": [128, 128],\n            \"cornerTopRight\": [256, 128], \"cornerBottomLeft\": [128, 256], \"cornerBottomRight\": [0, 256]\n        };\n        for (var i = 0; i < this._mapArray.length; i++) {\n            switch (this._mapArray[i]) {\n                case 0:\n                    sx = sourceRoad[\"straightVertical\"][0];\n                    sy = sourceRoad[\"straightVertical\"][1];\n                    break;\n                case 1:\n                    sx = sourceRoad[\"straightHorizontal\"][0];\n                    sy = sourceRoad[\"straightHorizontal\"][1];\n                    break;\n                case 2:\n                    sx = sourceRoad[\"cornerTopLeft\"][0];\n                    sy = sourceRoad[\"cornerTopLeft\"][1];\n                    break;\n                case 3:\n                    sx = sourceRoad[\"cornerTopRight\"][0];\n                    sy = sourceRoad[\"cornerTopRight\"][1];\n                    break;\n                case 4:\n                    sx = sourceRoad[\"cornerBottomLeft\"][0];\n                    sy = sourceRoad[\"cornerBottomLeft\"][1];\n                    break;\n                case 5:\n                    sx = sourceRoad[\"cornerBottomRight\"][0];\n                    sy = sourceRoad[\"cornerBottomRight\"][1];\n                    break;\n                default:\n                    continue;\n            }\n            if (!type)\n                this._mapContext.drawImage(this._imageRoadHidden, sx, sy, 128, 128, (i % this._width) * this._tileSize, Math.floor(i / this._width) * this._tileSize, this._tileSize, this._tileSize);\n            else {\n                if (this._roadType == 1)\n                    this._mapContext.drawImage(this._imageRoadConcrete, sx, sy, 128, 128, (i % this._width) * this._tileSize, Math.floor(i / this._width) * this._tileSize, this._tileSize, this._tileSize);\n                else\n                    this._mapContext.drawImage(this._imageRoadDust, sx, sy, 128, 128, (i % this._width) * this._tileSize, Math.floor(i / this._width) * this._tileSize, this._tileSize, this._tileSize);\n            }\n        }\n    }\n}\nexports.Track = Track;\n\n\n//# sourceURL=webpack://jeu/./Classes/Track.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./App.ts");
/******/ 	
/******/ })()
;